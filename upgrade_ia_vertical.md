# ü§ñ UPGRADE IA VERTICAL - ETF Curator

## üìå VIS√ÉO GERAL

Este documento especifica a implementa√ß√£o de um agente de IA vertical no ETF Curator utilizando o framework AutoGen, com interface conversacional estilo GPT/Perplexity. O agente ser√° capaz de entender comandos em linguagem natural, executar funcionalidades internas da aplica√ß√£o e retornar resultados contextualizados.

### üéØ Objetivos Principais

- **Interface Conversacional**: Chat intuitivo para intera√ß√£o com todas as funcionalidades
- **Execu√ß√£o Inteligente**: Acesso a APIs internas via comandos de linguagem natural
- **Mem√≥ria Contextual**: Hist√≥rico de conversas e projetos salvos
- **Racioc√≠nio Multi-Etapa**: An√°lises complexas usando MCP Sequential
- **Integra√ß√£o Total**: Aproveitar toda a infraestrutura existente do ETF Curator

---

## üèóÔ∏è ARQUITETURA ATUAL - AN√ÅLISE DE VIABILIDADE

### ‚úÖ Recursos Dispon√≠veis

**Base de Dados Rica (Supabase)**
- 1.370 ETFs ativos com m√©tricas completas
- Tabelas: `etfs_ativos_reais`, `user_portfolio_allocations`, `portfolio_tracking`
- M√©tricas: retornos, volatilidade, Sharpe ratio, dividendos, drawdown

**APIs Robustas Existentes**
```typescript
// Portfolio APIs
/api/portfolio/unified-master       // Otimiza√ß√£o Markowitz
/api/portfolio/unified-recommendations
/api/portfolio/save                 // Persist√™ncia de carteiras
/api/portfolio/real-data           // Tracking real vs simulado
/api/portfolio/performance
/api/portfolio/backtest

// ETF APIs  
/api/etfs/screener                 // Filtros avan√ßados
/api/etfs/rankings                 // Rankings din√¢micos
/api/etfs/details/[symbol]         // Detalhes espec√≠ficos
/api/etfs/comparator              // Compara√ß√£o lado a lado
```

**Componentes Frontend Reutiliz√°veis**
- `UnifiedPortfolioMaster.tsx` - Cria√ß√£o de carteiras
- `AdvancedRecommendations.tsx` - Sistema de recomenda√ß√µes
- `ETFTable.tsx` - Visualiza√ß√£o de dados
- `PerformanceChart.tsx` - Gr√°ficos de performance

**MCPs Integrados**
- ‚úÖ MCP Supabase - Acesso direto ao banco
- ‚úÖ MCP Memory - Gest√£o de contexto
- ‚úÖ MCP Sequential - Racioc√≠nio multi-etapa
- ‚úÖ MCP Perplexity - Pesquisa web complementar

---

## ü§ñ ARQUITETURA DO AGENTE IA

### üß† Sistema Multi-Agente (AutoGen)

```mermaid
graph TD
    A[User Input] --> B[Planner Agent]
    B --> C[Intent Classification]
    C --> D[Executor Agent]
    D --> E[API Calls]
    E --> F[Data Processing]
    F --> G[Writer Agent]
    G --> H[Natural Language Response]
    H --> I[Memory Agent]
    I --> J[Context Storage]
    
    K[MCP Supabase] --> E
    L[MCP Sequential] --> B
    M[MCP Memory] --> I
    N[MCP Perplexity] --> G
```

### üîπ Planner Agent

**Responsabilidades:**
- An√°lise de inten√ß√£o do usu√°rio via NLP
- Classifica√ß√£o de comandos em categorias de a√ß√£o
- Defini√ß√£o de pipeline de execu√ß√£o
- Uso do MCP Sequential para decis√µes complexas

**Classifica√ß√µes de Intent:**
```typescript
enum UserIntent {
  PORTFOLIO_OPTIMIZATION = 'optimize_portfolio',
  ETF_SCREENING = 'screen_etfs', 
  ETF_COMPARISON = 'compare_etfs',
  MARKET_ANALYSIS = 'analyze_market',
  EDUCATIONAL = 'explain_concept',
  PROJECT_MANAGEMENT = 'manage_project'
}
```

**Exemplo de Implementa√ß√£o:**
```typescript
class PlannerAgent {
  async analyzeIntent(message: string): Promise<ExecutionPlan> {
    const analysis = await this.mcpSequential.analyze({
      input: message,
      context: await this.mcpMemory.getRecentContext(),
      steps: [
        'extract_keywords',
        'classify_intent', 
        'identify_parameters',
        'plan_execution'
      ]
    });
    
    return {
      intent: analysis.intent,
      parameters: analysis.parameters,
      executionSteps: analysis.steps,
      requiredAPIs: this.mapIntentToAPIs(analysis.intent)
    };
  }
}
```

### üîπ Executor Agent

**Responsabilidades:**
- Execu√ß√£o de chamadas para APIs internas
- Valida√ß√£o de par√¢metros e seguran√ßa
- Processamento de dados retornados
- Tratamento de erros e fallbacks

**Mapeamento de Funcionalidades:**
```typescript
const API_MAPPINGS = {
  optimize_portfolio: {
    endpoint: '/api/portfolio/unified-master',
    requiredParams: ['objective', 'riskProfile', 'investment'],
    optionalParams: ['currency', 'constraints']
  },
  screen_etfs: {
    endpoint: '/api/etfs/screener', 
    requiredParams: ['filters'],
    optionalParams: ['sortBy', 'limit']
  },
  compare_etfs: {
    endpoint: '/api/etfs/comparator',
    requiredParams: ['symbols'],
    optionalParams: ['metrics']
  },
  analyze_rankings: {
    endpoint: '/api/etfs/rankings',
    requiredParams: ['category'],
    optionalParams: ['limit']
  }
};
```

**Implementa√ß√£o com Seguran√ßa:**
```typescript
class ExecutorAgent {
  async executeAPI(plan: ExecutionPlan, userContext: UserContext): Promise<APIResult> {
    // Valida√ß√£o de permiss√µes
    if (!this.validateUserPermissions(userContext, plan.intent)) {
      throw new Error('Insufficient permissions');
    }
    
    // Sanitiza√ß√£o de par√¢metros
    const sanitizedParams = this.sanitizeParameters(plan.parameters);
    
    // Execu√ß√£o com retry e timeout
    const result = await this.withRetry(async () => {
      return await fetch(plan.endpoint, {
        method: 'POST',
        headers: this.getAuthHeaders(userContext),
        body: JSON.stringify(sanitizedParams),
        timeout: 30000
      });
    });
    
    return this.processAPIResponse(result);
  }
}
```

### üîπ Writer Agent

**Responsabilidades:**
- Formata√ß√£o de respostas em linguagem natural
- Explica√ß√µes did√°ticas de conceitos financeiros
- Integra√ß√£o com pesquisa web (Perplexity)
- Gera√ß√£o de relat√≥rios estruturados

**Capacidades de Escrita:**
```typescript
class WriterAgent {
  async formatResponse(data: APIResult, intent: UserIntent): Promise<string> {
    const templates = {
      portfolio_optimization: this.generatePortfolioReport,
      etf_screening: this.generateScreeningReport,
      market_analysis: this.generateMarketInsights,
      educational: this.generateEducationalContent
    };
    
    let response = await templates[intent](data);
    
    // Enriquecimento com dados externos se necess√°rio
    if (this.needsExternalData(intent)) {
      const externalData = await this.mcpPerplexity.search({
        query: this.generateSearchQuery(data),
        limit: 3
      });
      response = this.enrichWithExternalData(response, externalData);
    }
    
    return response;
  }
  
  private generatePortfolioReport(data: PortfolioResult): string {
    return `
## üìä An√°lise de Carteira Otimizada

**Perfil de Risco:** ${data.riskProfile}
**Objetivo:** ${data.objective}
**Investimento:** ${formatCurrency(data.investment)}

### üéØ Composi√ß√£o Recomendada:
${data.allocations.map(etf => 
  `- **${etf.symbol}** (${etf.percentage}%): ${etf.name}
    - Taxa: ${etf.expenseRatio}% a.a.
    - Retorno 12m: ${etf.returns12m}%
    - Volatilidade: ${etf.volatility}%`
).join('\n')}

### üìà M√©tricas Esperadas:
- **Retorno Esperado:** ${data.expectedReturn}% a.a.
- **Volatilidade:** ${data.expectedVolatility}%
- **Sharpe Ratio:** ${data.sharpeRatio}
- **M√°ximo Drawdown:** ${data.maxDrawdown}%

### üí° Justificativa:
${this.generateJustification(data)}
    `;
  }
}
```

### üîπ Memory Agent

**Responsabilidades:**
- Armazenamento de contexto de conversas
- Gest√£o de projetos salvos
- Recupera√ß√£o de hist√≥rico relevante
- An√°lise de padr√µes de uso

**Estrutura de Dados:**
```typescript
interface ConversationContext {
  sessionId: string;
  userId: string;
  timestamp: Date;
  messages: Message[];
  extractedEntities: Entity[];
  userPreferences: UserPreferences;
  projectsReferenced: string[];
}

interface SavedProject {
  id: string;
  name: string;
  type: 'portfolio' | 'analysis' | 'strategy';
  data: any;
  createdAt: Date;
  lastAccessed: Date;
  tags: string[];
}
```

**Implementa√ß√£o:**
```typescript
class MemoryAgent {
  async saveConversation(context: ConversationContext): Promise<void> {
    // Salvar no MCP Memory para busca sem√¢ntica
    await this.mcpMemory.createEntities([{
      name: `conversation_${context.sessionId}`,
      entityType: 'conversation',
      observations: [
        `User discussed ${context.extractedEntities.join(', ')}`,
        `Session duration: ${context.duration}`,
        `Intent: ${context.primaryIntent}`
      ]
    }]);
    
    // Salvar detalhes no Supabase
    await this.supabase
      .from('user_conversations')
      .insert({
        session_id: context.sessionId,
        user_id: context.userId,
        data: context,
        created_at: new Date()
      });
  }
  
  async getRelevantContext(userId: string, currentMessage: string): Promise<Context> {
    // Busca sem√¢ntica no MCP Memory
    const semanticResults = await this.mcpMemory.searchNodes({
      query: currentMessage
    });
    
    // Contexto recente do Supabase
    const recentContext = await this.supabase
      .from('user_conversations')
      .select('*')
      .eq('user_id', userId)
      .order('created_at', { ascending: false })
      .limit(5);
    
    return this.mergeContextSources(semanticResults, recentContext);
  }
}
```

---

## üîÑ FLUXOS DE TRABALHO

### üìù Exemplo 1: Otimiza√ß√£o de Carteira

**Input do Usu√°rio:**
> "Quero uma carteira conservadora para aposentadoria com R$ 50.000, focada em dividendos e baixo risco"

**Fluxo de Execu√ß√£o:**
```typescript
// 1. Planner Agent
const plan = await plannerAgent.analyzeIntent(userMessage);
// Result: {
//   intent: 'optimize_portfolio',
//   parameters: {
//     objective: 'retirement',
//     riskProfile: 'conservative', 
//     investment: 50000,
//     currency: 'BRL',
//     focus: 'dividends'
//   }
// }

// 2. Executor Agent
const portfolioResult = await executorAgent.executeAPI(plan, userContext);
// Chama: POST /api/portfolio/unified-master

// 3. Writer Agent
const response = await writerAgent.formatResponse(portfolioResult, plan.intent);

// 4. Memory Agent
await memoryAgent.saveConversation({
  sessionId: currentSession.id,
  intent: plan.intent,
  result: portfolioResult,
  userSatisfaction: 'pending'
});
```

**Output Esperado:**
```markdown
## üéØ Carteira Conservadora para Aposentadoria

Baseado no seu perfil conservador e foco em dividendos, criei uma carteira otimizada:

### üìä Composi√ß√£o Recomendada:
- **VYM** (35%): Vanguard High Dividend Yield ETF
  - Taxa: 0.06% a.a. | Dividend Yield: 2.8% | Volatilidade: 14%
- **SCHD** (25%): Schwab US Dividend Equity ETF  
  - Taxa: 0.06% a.a. | Dividend Yield: 3.2% | Volatilidade: 16%
- **BND** (25%): Vanguard Total Bond Market ETF
  - Taxa: 0.03% a.a. | Yield: 4.1% | Volatilidade: 6%
- **VXUS** (15%): Vanguard Total International Stock ETF
  - Taxa: 0.08% a.a. | Dividend Yield: 2.1% | Volatilidade: 18%

### üìà M√©tricas da Carteira:
- **Retorno Esperado:** 7.2% a.a.
- **Dividend Yield:** 2.9% a.a.
- **Volatilidade:** 11.8%
- **Sharpe Ratio:** 0.61

### üí° Por que essa composi√ß√£o?
Esta carteira prioriza **estabilidade e renda** atrav√©s de ETFs de dividendos de alta qualidade (VYM, SCHD) e bonds (BND) para reduzir volatilidade. A exposi√ß√£o internacional (VXUS) oferece diversifica√ß√£o geogr√°fica mantendo o perfil conservador.

**Pr√≥ximos passos:** Posso simular o crescimento dessa carteira ao longo de 20 anos ou ajustar as aloca√ß√µes conforme suas prefer√™ncias.
```

### üìù Exemplo 2: Screening de ETFs

**Input do Usu√°rio:**
> "Encontre ETFs de tecnologia com baixa taxa de administra√ß√£o e boa performance nos √∫ltimos 2 anos"

**Fluxo de Execu√ß√£o:**
```typescript
// 1. Planner Agent
const plan = await plannerAgent.analyzeIntent(userMessage);
// Result: {
//   intent: 'screen_etfs',
//   parameters: {
//     sector: 'technology',
//     maxExpenseRatio: 0.5,
//     minReturns24m: 10,
//     sortBy: 'returns_24m',
//     limit: 10
//   }
// }

// 2. Executor Agent  
const screeningResult = await executorAgent.executeAPI(plan, userContext);
// Chama: POST /api/etfs/screener

// 3. Writer Agent com pesquisa complementar
const marketContext = await mcpPerplexity.search({
  query: "technology ETF performance trends 2024",
  limit: 2
});

const response = await writerAgent.formatResponse(screeningResult, plan.intent, marketContext);
```

**Output Esperado:**
```markdown
## üîç ETFs de Tecnologia - Screening Otimizado

Encontrei **8 ETFs de tecnologia** que atendem seus crit√©rios:

### üèÜ Top 3 Recomendados:

**1. FTEC** - Fidelity MSCI Information Technology ETF
- **Taxa:** 0.08% a.a. ‚≠ê
- **Retorno 24m:** +28.4%
- **Volatilidade:** 22%
- **Holdings:** Apple (22%), Microsoft (19%), NVIDIA (8%)

**2. VGT** - Vanguard Information Technology ETF  
- **Taxa:** 0.10% a.a. ‚≠ê
- **Retorno 24m:** +27.8%
- **Volatilidade:** 21%
- **Holdings:** Similar ao FTEC, mais diversificado

**3. XLK** - Technology Select Sector SPDR Fund
- **Taxa:** 0.09% a.a. ‚≠ê  
- **Retorno 24m:** +26.9%
- **Volatilidade:** 23%
- **Holdings:** Foco nas maiores tech companies

### üìä An√°lise de Mercado:
Segundo dados recentes, o setor de tecnologia tem se beneficiado do boom de IA e cloud computing. ETFs com exposi√ß√£o a semicondutores (NVIDIA, AMD) tiveram performance superior.

**Recomenda√ß√£o:** FTEC oferece a melhor combina√ß√£o de baixa taxa e performance. Quer que eu compare esses 3 ETFs em mais detalhes?
```

---

## üíª IMPLEMENTA√á√ÉO T√âCNICA

### üèóÔ∏è Estrutura de Diret√≥rios

```
src/
‚îú‚îÄ‚îÄ agents/
‚îÇ   ‚îú‚îÄ‚îÄ planner/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PlannerAgent.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ IntentClassifier.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ExecutionPlanner.ts
‚îÇ   ‚îú‚îÄ‚îÄ executor/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ExecutorAgent.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ APIMapper.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SecurityValidator.ts
‚îÇ   ‚îú‚îÄ‚îÄ writer/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ WriterAgent.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ResponseFormatter.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ReportGenerator.ts
‚îÇ   ‚îî‚îÄ‚îÄ memory/
‚îÇ       ‚îú‚îÄ‚îÄ MemoryAgent.ts
‚îÇ       ‚îú‚îÄ‚îÄ ContextManager.ts
‚îÇ       ‚îî‚îÄ‚îÄ ProjectManager.ts
‚îú‚îÄ‚îÄ chat/
‚îÇ   ‚îú‚îÄ‚îÄ ChatInterface.tsx
‚îÇ   ‚îú‚îÄ‚îÄ MessageHandler.ts
‚îÇ   ‚îî‚îÄ‚îÄ StreamingResponse.tsx
‚îú‚îÄ‚îÄ orchestrator/
‚îÇ   ‚îú‚îÄ‚îÄ AgentOrchestrator.ts
‚îÇ   ‚îú‚îÄ‚îÄ WorkflowEngine.ts
‚îÇ   ‚îî‚îÄ‚îÄ ResponseStreamer.ts
‚îî‚îÄ‚îÄ types/
    ‚îú‚îÄ‚îÄ agents.ts
    ‚îú‚îÄ‚îÄ conversation.ts
    ‚îî‚îÄ‚îÄ workflow.ts
```

### üîß Configura√ß√£o do AutoGen

```typescript
// src/orchestrator/AgentOrchestrator.ts
import { AutoGenOrchestrator } from '@autogen/core';

export class ETFCuratorOrchestrator {
  private orchestrator: AutoGenOrchestrator;
  private agents: {
    planner: PlannerAgent;
    executor: ExecutorAgent; 
    writer: WriterAgent;
    memory: MemoryAgent;
  };

  constructor() {
    this.initializeAgents();
    this.setupOrchestrator();
  }

  private setupOrchestrator(): void {
    this.orchestrator = new AutoGenOrchestrator({
      agents: Object.values(this.agents),
      workflow: {
        maxTurns: 10,
        terminationCondition: this.isConversationComplete,
        humanInputMode: 'NEVER' // Fully autonomous
      }
    });
  }

  async processMessage(message: string, userId: string): Promise<string> {
    const context = await this.agents.memory.getRelevantContext(userId, message);
    
    const conversation = await this.orchestrator.initiate({
      message: {
        content: message,
        context: context,
        userId: userId
      },
      recipient: this.agents.planner
    });

    return await this.streamResponse(conversation);
  }
}
```

### üé® Interface de Chat

```tsx
// src/chat/ChatInterface.tsx
'use client';

import { useState, useRef, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card } from '@/components/ui/card';

interface Message {
  id: string;
  content: string;
  role: 'user' | 'assistant';
  timestamp: Date;
  metadata?: {
    intent?: string;
    executedAPIs?: string[];
    processingTime?: number;
  };
}

export default function ChatInterface() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const sendMessage = async () => {
    if (!input.trim()) return;

    const userMessage: Message = {
      id: crypto.randomUUID(),
      content: input,
      role: 'user',
      timestamp: new Date()
    };

    setMessages(prev => [...prev, userMessage]);
    setInput('');
    setIsLoading(true);

    try {
      const response = await fetch('/api/chat/agent', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: input })
      });

      const reader = response.body?.getReader();
      let assistantMessage: Message = {
        id: crypto.randomUUID(),
        content: '',
        role: 'assistant',
        timestamp: new Date()
      };

      setMessages(prev => [...prev, assistantMessage]);

      // Streaming response
      while (true) {
        const { done, value } = await reader!.read();
        if (done) break;

        const chunk = new TextDecoder().decode(value);
        const lines = chunk.split('\n');

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = JSON.parse(line.slice(6));
            if (data.content) {
              setMessages(prev => prev.map(msg => 
                msg.id === assistantMessage.id 
                  ? { ...msg, content: msg.content + data.content }
                  : msg
              ));
            }
          }
        }
      }
    } catch (error) {
      console.error('Error sending message:', error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="flex flex-col h-screen max-w-4xl mx-auto p-4">
      <div className="flex-1 overflow-y-auto space-y-4 mb-4">
        {messages.map(message => (
          <Card key={message.id} className={`p-4 ${
            message.role === 'user' 
              ? 'ml-auto max-w-[80%] bg-blue-50' 
              : 'mr-auto max-w-[90%]'
          }`}>
            <div className="prose prose-sm max-w-none">
              {message.role === 'assistant' ? (
                <div dangerouslySetInnerHTML={{ __html: markdownToHtml(message.content) }} />
              ) : (
                <p>{message.content}</p>
              )}
            </div>
            {message.metadata && (
              <div className="mt-2 text-xs text-gray-500">
                {message.metadata.intent && (
                  <span className="mr-2">Intent: {message.metadata.intent}</span>
                )}
                {message.metadata.processingTime && (
                  <span>Time: {message.metadata.processingTime}ms</span>
                )}
              </div>
            )}
          </Card>
        ))}
        <div ref={messagesEndRef} />
      </div>

      <div className="flex gap-2">
        <Input
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Pergunte sobre ETFs, carteiras, an√°lises..."
          onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
          disabled={isLoading}
        />
        <Button onClick={sendMessage} disabled={isLoading}>
          {isLoading ? 'Processando...' : 'Enviar'}
        </Button>
      </div>
    </div>
  );
}
```

### üöÄ API Route do Chat

```typescript
// src/app/api/chat/agent/route.ts
import { NextRequest } from 'next/server';
import { ETFCuratorOrchestrator } from '@/agents/orchestrator/AgentOrchestrator';
import { auth } from '@/lib/auth';

const orchestrator = new ETFCuratorOrchestrator();

export async function POST(request: NextRequest) {
  try {
    const { message } = await request.json();
    const user = await auth();
    
    if (!user) {
      return new Response('Unauthorized', { status: 401 });
    }

    // Streaming response
    const encoder = new TextEncoder();
    const stream = new ReadableStream({
      async start(controller) {
        try {
          const response = await orchestrator.processMessage(message, user.id);
          
          // Stream the response in chunks
          const chunks = response.split(' ');
          for (const chunk of chunks) {
            controller.enqueue(
              encoder.encode(`data: ${JSON.stringify({ content: chunk + ' ' })}\n\n`)
            );
            await new Promise(resolve => setTimeout(resolve, 50)); // Simulate typing
          }
          
          controller.enqueue(encoder.encode(`data: ${JSON.stringify({ done: true })}\n\n`));
          controller.close();
        } catch (error) {
          controller.enqueue(
            encoder.encode(`data: ${JSON.stringify({ error: error.message })}\n\n`)
          );
          controller.close();
        }
      }
    });

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/plain; charset=utf-8',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
      },
    });
  } catch (error) {
    return Response.json({ error: 'Internal server error' }, { status: 500 });
  }
}
```

---

## üó∫Ô∏è ROADMAP DE IMPLEMENTA√á√ÉO

### üìÖ Fase 1: MVP (4-6 semanas)

**Semana 1-2: Infraestrutura Base**
- [ ] Configura√ß√£o do AutoGen
- [ ] Estrutura b√°sica dos agentes
- [ ] Interface de chat simples
- [ ] Integra√ß√£o com MCP Supabase

**Semana 3-4: Agentes Core**
- [ ] Planner Agent com classifica√ß√£o de intent
- [ ] Executor Agent para APIs principais
- [ ] Writer Agent com templates b√°sicos
- [ ] Testes unit√°rios

**Semana 5-6: Integra√ß√£o e Testes**
- [ ] Orquestra√ß√£o completa
- [ ] Interface de usu√°rio polida
- [ ] Testes de integra√ß√£o
- [ ] Deploy em ambiente de teste

### üìÖ Fase 2: Funcionalidades Avan√ßadas (4-6 semanas)

**Semana 7-8: Memory e Contexto**
- [ ] Memory Agent completo
- [ ] Gest√£o de projetos salvos
- [ ] Hist√≥rico de conversas
- [ ] Busca sem√¢ntica

**Semana 9-10: Intelig√™ncia Avan√ßada**
- [ ] MCP Sequential para an√°lises complexas
- [ ] Integra√ß√£o com Perplexity
- [ ] Explica√ß√µes educativas
- [ ] Personaliza√ß√£o por perfil

**Semana 11-12: Otimiza√ß√£o**
- [ ] Performance e caching
- [ ] Monitoramento e m√©tricas
- [ ] Feedback do usu√°rio
- [ ] Refinamento de respostas

### üìÖ Fase 3: Produ√ß√£o (2-4 semanas)

**Semana 13-14: Produ√ß√£o**
- [ ] Deploy em produ√ß√£o
- [ ] Monitoramento avan√ßado
- [ ] Documenta√ß√£o completa
- [ ] Treinamento da equipe

**Semana 15-16: Itera√ß√£o**
- [ ] An√°lise de uso real
- [ ] Melhorias baseadas em feedback
- [ ] Expans√£o de funcionalidades
- [ ] Otimiza√ß√µes de performance

---

## üîí CONSIDERA√á√ïES DE SEGURAN√áA

### üõ°Ô∏è Autentica√ß√£o e Autoriza√ß√£o

```typescript
// Valida√ß√£o de permiss√µes por funcionalidade
const PERMISSION_MATRIX = {
  optimize_portfolio: ['starter', 'pro', 'wealth', 'offshore'],
  advanced_screening: ['pro', 'wealth', 'offshore'],
  save_unlimited_projects: ['wealth', 'offshore'],
  custom_reports: ['wealth', 'offshore']
};

class SecurityValidator {
  validateUserAccess(userPlan: string, intent: string): boolean {
    const requiredPlans = PERMISSION_MATRIX[intent];
    return requiredPlans?.includes(userPlan) ?? false;
  }

  sanitizeUserInput(input: string): string {
    // Remove SQL injection attempts, XSS, etc.
    return input
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      .replace(/javascript:/gi, '')
      .replace(/on\w+\s*=/gi, '');
  }
}
```

### üîç Auditoria e Monitoramento

```typescript
// Logging detalhado de todas as intera√ß√µes
interface AuditLog {
  userId: string;
  sessionId: string;
  intent: string;
  apisCalled: string[];
  processingTime: number;
  success: boolean;
  error?: string;
  timestamp: Date;
}

class AuditLogger {
  async logInteraction(log: AuditLog): Promise<void> {
    await this.supabase
      .from('agent_audit_logs')
      .insert(log);
    
    // Alertas para comportamento suspeito
    if (this.detectSuspiciousActivity(log)) {
      await this.sendSecurityAlert(log);
    }
  }
}
```

---

## üìä M√âTRICAS E MONITORAMENTO

### üéØ KPIs de Sucesso

**M√©tricas de Uso**
- N√∫mero de conversas por usu√°rio
- Taxa de conclus√£o de tarefas
- Tempo m√©dio de resposta
- Satisfa√ß√£o do usu√°rio (thumbs up/down)

**M√©tricas T√©cnicas**
- Lat√™ncia de resposta por agente
- Taxa de erro por API
- Uso de recursos (CPU, mem√≥ria)
- Precis√£o da classifica√ß√£o de intent

**M√©tricas de Neg√≥cio**
- Convers√£o para planos pagos
- Reten√ß√£o de usu√°rios
- Projetos salvos por usu√°rio
- APIs mais utilizadas

### üìà Dashboard de Monitoramento

```typescript
// M√©tricas em tempo real
const METRICS_DASHBOARD = {
  realtime: {
    activeConversations: 0,
    averageResponseTime: 0,
    errorRate: 0,
    apiCallsPerMinute: 0
  },
  daily: {
    totalConversations: 0,
    uniqueUsers: 0,
    successfulTasks: 0,
    averageSessionDuration: 0
  }
};
```

---

## üöÄ COMANDOS DE EXEMPLO

### üíº Portfolio Management
```
"Crie uma carteira agressiva de crescimento com $100k"
"Otimize minha carteira atual para reduzir risco"
"Compare minha carteira com o S&P 500"
"Simule o crescimento da carteira em 10 anos"
```

### üîç ETF Analysis
```
"Encontre ETFs de dividendos com taxa baixa"
"Compare QQQ vs VTI vs SPY"
"Explique a diferen√ßa entre SCHD e VYM"
"Quais ETFs de bonds t√™m melhor Sharpe ratio?"
```

### üìä Market Insights
```
"Como est√° o mercado de ETFs hoje?"
"Quais setores est√£o em alta?"
"ETFs de tecnologia vs sa√∫de: qual escolher?"
"Tend√™ncias de ESG em ETFs"
```

### üéì Educational
```
"O que √© expense ratio e por que importa?"
"Como funciona a otimiza√ß√£o de Markowitz?"
"Explique dividend yield vs total return"
"Diferen√ßa entre ETF e fundo m√∫tuo"
```

---

## ‚úÖ CHECKLIST DE IMPLEMENTA√á√ÉO

### üèóÔ∏è Setup Inicial
- [ ] Instalar depend√™ncias do AutoGen
- [ ] Configurar vari√°veis de ambiente
- [ ] Criar estrutura de diret√≥rios
- [ ] Configurar MCPs (Supabase, Memory, Sequential, Perplexity)

### ü§ñ Desenvolvimento dos Agentes
- [ ] PlannerAgent com classifica√ß√£o de intent
- [ ] ExecutorAgent com mapeamento de APIs
- [ ] WriterAgent com formata√ß√£o de respostas
- [ ] MemoryAgent com persist√™ncia de contexto

### üé® Interface do Usu√°rio
- [ ] Componente de chat com streaming
- [ ] Hist√≥rico de conversas
- [ ] Projetos salvos
- [ ] Configura√ß√µes do agente

### üîß Integra√ß√£o
- [ ] Orquestrador principal
- [ ] API routes para chat
- [ ] Middleware de autentica√ß√£o
- [ ] Sistema de permiss√µes

### üß™ Testes
- [ ] Testes unit√°rios dos agentes
- [ ] Testes de integra√ß√£o das APIs
- [ ] Testes de interface do usu√°rio
- [ ] Testes de performance

### üöÄ Deploy
- [ ] Configura√ß√£o de produ√ß√£o
- [ ] Monitoramento e alertas
- [ ] Documenta√ß√£o t√©cnica
- [ ] Treinamento da equipe

---

## üí° CONSIDERA√á√ïES FINAIS

### üéØ Benef√≠cios Esperados

1. **Experi√™ncia do Usu√°rio Superior**: Interface conversacional intuitiva
2. **Maior Engajamento**: Intera√ß√£o natural vs formul√°rios complexos
3. **Democratiza√ß√£o**: Acesso f√°cil a an√°lises financeiras avan√ßadas
4. **Escalabilidade**: Atendimento 24/7 sem limita√ß√µes humanas
5. **Personaliza√ß√£o**: Respostas adaptadas ao perfil do usu√°rio

### ‚ö†Ô∏è Riscos e Mitiga√ß√µes

**Risco**: Respostas incorretas ou imprecisas
**Mitiga√ß√£o**: Valida√ß√£o rigorosa, fontes confi√°veis, disclaimers claros

**Risco**: Sobrecarga de APIs internas
**Mitiga√ß√£o**: Rate limiting, caching, otimiza√ß√£o de queries

**Risco**: Seguran√ßa e privacidade
**Mitiga√ß√£o**: Auditoria completa, criptografia, conformidade LGPD

### üîÆ Vis√£o Futura

- **Integra√ß√£o com Corretoras**: Execu√ß√£o autom√°tica de trades
- **An√°lise Preditiva**: ML para previs√µes de mercado
- **Relat√≥rios Personalizados**: PDFs autom√°ticos para clientes
- **Multi-idioma**: Suporte internacional
- **Voz**: Interface por comando de voz

---

**üìù Documento criado em:** Janeiro 2025  
**üîÑ √öltima atualiza√ß√£o:** Janeiro 2025  
**üë• Equipe respons√°vel:** Desenvolvimento ETF Curator  
**üìß Contato:** [contato@etfcurator.com](mailto:contato@etfcurator.com) 